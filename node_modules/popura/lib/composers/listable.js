'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = listable;

var _request = require('../utils/request');

var _outputApiValues = require('../utils/output-api-values');

var debug = require('debug')('popura:listable');

/**
 * Let me explain this shit. Sometimes, MAL returns '201 Created'.
 * Sometimes it returns a transation ID.
 */
var checkAddResponse = function checkAddResponse(body) {
	return body && (Number(body) > 0 || body.includes('201 Created'));
};

/**
 * Composes an object that abstracts MAL's lists API
 *
 * @param  {object} state
 * @return {object} - An object that can manipulate MAL's lists
 */
function listable(state) {
	return {
		/**
   * @param  {string} username = state.username
   * @return {Promise}
   */

		getAnimeList: function getAnimeList() {
			var username = arguments.length <= 0 || arguments[0] === undefined ? state.username : arguments[0];

			debug('Getting animelist of ' + username);
			return (0, _request.requestList)(state.authToken, 'anime', username);
		},


		/**
   * @param  {string} username = state.username
   * @return {Promise}
   */
		getMangaList: function getMangaList() {
			var username = arguments.length <= 0 || arguments[0] === undefined ? state.username : arguments[0];

			debug('Getting mangalist of ' + username);
			return (0, _request.requestList)(state.authToken, 'manga', username);
		},


		/**
   * @param  {int} id
   * @param  {object} values = {}
   * @return {Promise}
   */
		addAnime: function addAnime(id) {
			var values = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

			if (!values.status) {
				values.status = 1;
			}

			return (0, _request.postXml)(state.authToken, '/animelist/add/' + id + '.xml', {
				body: { data: (0, _outputApiValues.outputAnimeValues)(values) }
			}, checkAddResponse);
		},


		/**
   * @param  {int} id
   * @param  {object} values = {}
   * @return {Promise}
   */
		addManga: function addManga(id) {
			var values = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

			if (!values.status) {
				values.status = 1;
			}

			return (0, _request.postXml)(state.authToken, '/mangalist/add/' + id + '.xml', {
				body: { data: (0, _outputApiValues.outputMangaValues)(values) }
			}, checkAddResponse);
		},


		/**
   * @param  {int} id
   * @param  {object} values = {}
   * @return {Promise}
   */
		updateAnime: function updateAnime(id) {
			var values = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

			return (0, _request.postXml)(state.authToken, '/animelist/update/' + id + '.xml', {
				body: { data: (0, _outputApiValues.outputAnimeValues)(values) }
			}, 'Updated');
		},


		/**
   * @param  {int} id
   * @param  {object} values = {}
   * @return {Promise}
   */
		updateManga: function updateManga(id) {
			var values = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

			return (0, _request.postXml)(state.authToken, '/mangalist/update/' + id + '.xml', {
				body: { data: (0, _outputApiValues.outputMangaValues)(values) }
			}, 'Updated');
		},


		/**
   * @param  {int} id
   * @return {Promise}
   */
		deleteAnime: function deleteAnime(id) {
			return (0, _request.postXml)(state.authToken, '/animelist/delete/' + id + '.xml', {}, 'Deleted');
		},


		/**
   * @param  {int} id
   * @return {Promise}
   */
		deleteManga: function deleteManga(id) {
			return (0, _request.postXml)(state.authToken, '/mangalist/delete/' + id + '.xml', {}, 'Deleted');
		}
	};
}
module.exports = exports['default'];